rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is in allowed list
    function isAllowedUser() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/config/allowedUsers) &&
             request.auth.uid in get(/databases/$(database)/documents/config/allowedUsers).data.uids;
    }
    
    // Config collection - read-only for authenticated users
    match /config/{document} {
      allow read: if isAuthenticated();
      allow write: if false; // Manually managed only
    }
    
    // Messages collection
    match /messages/{messageId} {
      // Only allowed users can read messages
      allow read: if isAllowedUser();
      
      // Only allowed users can create messages
      // Ensure required fields are present and senderUID matches authenticated user
      allow create: if isAllowedUser() &&
                      request.auth.uid == request.resource.data.senderUID &&
                      request.resource.data.keys().hasAll(['text', 'senderUID', 'senderName', 'timestamp', 'hiddenFor']) &&
                      request.resource.data.hiddenFor is list;
      
      // Users can only update their own hiddenFor entry
      // This allows "hide for me" functionality
      allow update: if isAllowedUser() &&
                      request.auth.uid in request.resource.data.hiddenFor &&
                      !(request.auth.uid in resource.data.hiddenFor) &&
                      // Ensure only hiddenFor is being modified
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['hiddenFor']);
      
      // No deletes allowed - messages can only be hidden
      allow delete: if false;
    }

    // Users collection
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
  }
}
